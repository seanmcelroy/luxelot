# fserve

This app provides an FTP-like service over Luxelot.  The purpose of this app is to provide a way to offer and access node-based storage.  This is in contrast to "network-based" storage, which would use more traditional distributed hash table principles.

It includes handshake messages over Luxelot, similar to how the Luxelot Syn/Ack key exchanges work, to enable E2EE between the file server and client 'connections' using the Luxelot network.

## Authentication sequence

### auth_channel_begin
```proto
message AuthChannelBegin {
    uint32 prot_ver = 1;
    bytes session_pub_key = 2;
}
```

1. Syn messages include an application protocol version.  Any breaking change to this app's message requires an increment of the protocol version.

2. A CRYSTALS-Kyber public/private keypair is generated by the file serve **FOR THE PURPOSES OF THIS SESSION ONLY**, and the Kyber public key is shared.  This will form the basis of a shared session key establishment between the sender and the receiver after the auth_channel_response is exchanged.  This creates end-to-end encryption between the fserve client and the fserve server over the message-passing Luxelot network.  This key is not used for any future sessions, even with the same principal who logs in subsequently.

### auth_channel_response

```proto
message AuthChannelResponse {
    uint32 prot_ver = 1;
    int32 status = 2;
    string status_message = 3;
    bytes cipher_text = 4;
    bytes id_pub_key = 5;
}
```

Receiving fserves respond with the auth_channel_response message if they wish to accept the fserve connection.  Note, this looks very similar to the Luxelot "Ack" message, and is used to complete the E2EE session between the fserve client and fserve server over the Luxelot network.

1. Similar to `auth_channel_begin`, the receiving fserve replies with its protocol version.  Receiving fserves MAY choose to accept connections from sending clients with any lower protocol version, provided they offer backwards compatibility for the core message set.  Receiving servers MUST NOT accept connections from clients with a higher protocol version number, as they cannot know whether they will be forwards compatible.

2. The cipher text is generated using the Kyber public key received from the sending client in the `auth_channel_begin` message and the private Kyber key generated by this fserve server.  This is the Kyber Key Encapsulation Mechanism (KEM) and will be decoded by the receiving fserve server and will complete the shared session key establishment.

3. The receiving fserve server replies with its own public Dilithium key that is consistently used in all its identification and message signing on the network.  Similar to the use of this field in Syn, this allows the sending client to validate future messages from this receiving fserve that it may see originated from it.

NOTE: Fserve protocol-aware nodes on the network path of the message passing CAN see and MAY remember this client's Dilithiuim public key to validate future messages of any type signed and passed through the node subsequently.

### auth_user_begin

```proto
message AuthUserBegin {
    bytes principal = 1;
    InitialUserChallengeType initial_user_challenge_type = 2;
    bytes initial_user_challenge_data = 3;
}

enum InitialUserChallengeType {
    NONE = 0;
    PASSWORD = 1;
}
```

TODO

### auth_user_challenge

```proto
message AuthUserChallenge {
    bytes principal = 1;
    UserChallengeType user_challenge_type = 2;
}

enum UserChallengeType {
    NONE = 0;
    PASSWORD = 1;
    OTP = 2;
}
```

TODO

### auth_user_response

```proto
message AuthUserResponse {
    int32 status_code = 1;
    string status_message = 2;
    AdditionalUserChallengeType additional_user_challenge_type = 3;
    bytes additional_user_challenge_data = 4;
}

enum AdditionalUserChallengeType {
    NONE = 0;
    PASSWORD = 1;
    OTP = 2;
}
```

(Additional user challenge/responses may be seen if the server implements multi-factor authentication or allows retries for failed authentication attempts.)

## File download sequences

### prepare_download

Preparing a download asks the server to begin a store operation across Luxelot to deliver the file.  This message is sent using the E2EE encrypted session keys for the fserve session as established in the authentication sequence, documented above.  The response to this message is metadata about various chunks, or pieces, that will be submitted.

Either the server or the client may request the file transfer to be encrypted when the server sends chunks to the client.  If either the server or the client requests encryption, then the server WILL send chunks wrapped in a server_frame.  If neither request encryption, then the server MAY send chunks directly, which cacn allow protocol-aware networking nodes on the message-passing path to store a copy of the data in their distributed hash tables.

### get_download

